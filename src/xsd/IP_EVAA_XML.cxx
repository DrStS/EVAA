// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IP_EVAA_XML.hxx"

// vector_legs_t
// 

const vector_legs_t::rr_type& vector_legs_t::
rr () const
{
  return this->rr_.get ();
}

vector_legs_t::rr_type& vector_legs_t::
rr ()
{
  return this->rr_.get ();
}

void vector_legs_t::
rr (const rr_type& x)
{
  this->rr_.set (x);
}

const vector_legs_t::rl_type& vector_legs_t::
rl () const
{
  return this->rl_.get ();
}

vector_legs_t::rl_type& vector_legs_t::
rl ()
{
  return this->rl_.get ();
}

void vector_legs_t::
rl (const rl_type& x)
{
  this->rl_.set (x);
}

const vector_legs_t::fl_type& vector_legs_t::
fl () const
{
  return this->fl_.get ();
}

vector_legs_t::fl_type& vector_legs_t::
fl ()
{
  return this->fl_.get ();
}

void vector_legs_t::
fl (const fl_type& x)
{
  this->fl_.set (x);
}

const vector_legs_t::fr_type& vector_legs_t::
fr () const
{
  return this->fr_.get ();
}

vector_legs_t::fr_type& vector_legs_t::
fr ()
{
  return this->fr_.get ();
}

void vector_legs_t::
fr (const fr_type& x)
{
  this->fr_.set (x);
}


// car_settings_t
// 

const car_settings_t::car_type& car_settings_t::
car () const
{
  return this->car_.get ();
}

car_settings_t::car_type& car_settings_t::
car ()
{
  return this->car_.get ();
}

void car_settings_t::
car (const car_type& x)
{
  this->car_.set (x);
}

void car_settings_t::
car (::std::auto_ptr< car_type > x)
{
  this->car_.set (x);
}

const car_settings_t::initial_type& car_settings_t::
initial () const
{
  return this->initial_.get ();
}

car_settings_t::initial_type& car_settings_t::
initial ()
{
  return this->initial_.get ();
}

void car_settings_t::
initial (const initial_type& x)
{
  this->initial_.set (x);
}

void car_settings_t::
initial (::std::auto_ptr< initial_type > x)
{
  this->initial_.set (x);
}

const car_settings_t::external_type& car_settings_t::
external () const
{
  return this->external_.get ();
}

car_settings_t::external_type& car_settings_t::
external ()
{
  return this->external_.get ();
}

void car_settings_t::
external (const external_type& x)
{
  this->external_.set (x);
}

void car_settings_t::
external (::std::auto_ptr< external_type > x)
{
  this->external_.set (x);
}

const car_settings_t::simulation_type& car_settings_t::
simulation () const
{
  return this->simulation_.get ();
}

car_settings_t::simulation_type& car_settings_t::
simulation ()
{
  return this->simulation_.get ();
}

void car_settings_t::
simulation (const simulation_type& x)
{
  this->simulation_.set (x);
}

void car_settings_t::
simulation (::std::auto_ptr< simulation_type > x)
{
  this->simulation_.set (x);
}


// car
// 

const car::k_tyre_type& car::
k_tyre () const
{
  return this->k_tyre_.get ();
}

car::k_tyre_type& car::
k_tyre ()
{
  return this->k_tyre_.get ();
}

void car::
k_tyre (const k_tyre_type& x)
{
  this->k_tyre_.set (x);
}

void car::
k_tyre (::std::auto_ptr< k_tyre_type > x)
{
  this->k_tyre_.set (x);
}

const car::k_body_type& car::
k_body () const
{
  return this->k_body_.get ();
}

car::k_body_type& car::
k_body ()
{
  return this->k_body_.get ();
}

void car::
k_body (const k_body_type& x)
{
  this->k_body_.set (x);
}

void car::
k_body (::std::auto_ptr< k_body_type > x)
{
  this->k_body_.set (x);
}

const car::l_lat_type& car::
l_lat () const
{
  return this->l_lat_.get ();
}

car::l_lat_type& car::
l_lat ()
{
  return this->l_lat_.get ();
}

void car::
l_lat (const l_lat_type& x)
{
  this->l_lat_.set (x);
}

void car::
l_lat (::std::auto_ptr< l_lat_type > x)
{
  this->l_lat_.set (x);
}

const car::l_long_type& car::
l_long () const
{
  return this->l_long_.get ();
}

car::l_long_type& car::
l_long ()
{
  return this->l_long_.get ();
}

void car::
l_long (const l_long_type& x)
{
  this->l_long_.set (x);
}

void car::
l_long (::std::auto_ptr< l_long_type > x)
{
  this->l_long_.set (x);
}

const car::mass_wheel_type& car::
mass_wheel () const
{
  return this->mass_wheel_.get ();
}

car::mass_wheel_type& car::
mass_wheel ()
{
  return this->mass_wheel_.get ();
}

void car::
mass_wheel (const mass_wheel_type& x)
{
  this->mass_wheel_.set (x);
}

void car::
mass_wheel (::std::auto_ptr< mass_wheel_type > x)
{
  this->mass_wheel_.set (x);
}

const car::mass_tyre_type& car::
mass_tyre () const
{
  return this->mass_tyre_.get ();
}

car::mass_tyre_type& car::
mass_tyre ()
{
  return this->mass_tyre_.get ();
}

void car::
mass_tyre (const mass_tyre_type& x)
{
  this->mass_tyre_.set (x);
}

void car::
mass_tyre (::std::auto_ptr< mass_tyre_type > x)
{
  this->mass_tyre_.set (x);
}

const car::lower_spring_length_type& car::
lower_spring_length () const
{
  return this->lower_spring_length_.get ();
}

car::lower_spring_length_type& car::
lower_spring_length ()
{
  return this->lower_spring_length_.get ();
}

void car::
lower_spring_length (const lower_spring_length_type& x)
{
  this->lower_spring_length_.set (x);
}

void car::
lower_spring_length (::std::auto_ptr< lower_spring_length_type > x)
{
  this->lower_spring_length_.set (x);
}

const car::upper_spring_length_type& car::
upper_spring_length () const
{
  return this->upper_spring_length_.get ();
}

car::upper_spring_length_type& car::
upper_spring_length ()
{
  return this->upper_spring_length_.get ();
}

void car::
upper_spring_length (const upper_spring_length_type& x)
{
  this->upper_spring_length_.set (x);
}

void car::
upper_spring_length (::std::auto_ptr< upper_spring_length_type > x)
{
  this->upper_spring_length_.set (x);
}

const car::mass_body_type& car::
mass_body () const
{
  return this->mass_body_.get ();
}

car::mass_body_type& car::
mass_body ()
{
  return this->mass_body_.get ();
}

void car::
mass_body (const mass_body_type& x)
{
  this->mass_body_.set (x);
}

const car::I_body_xx_type& car::
I_body_xx () const
{
  return this->I_body_xx_.get ();
}

car::I_body_xx_type& car::
I_body_xx ()
{
  return this->I_body_xx_.get ();
}

void car::
I_body_xx (const I_body_xx_type& x)
{
  this->I_body_xx_.set (x);
}

const car::I_body_zz_type& car::
I_body_zz () const
{
  return this->I_body_zz_.get ();
}

car::I_body_zz_type& car::
I_body_zz ()
{
  return this->I_body_zz_.get ();
}

void car::
I_body_zz (const I_body_zz_type& x)
{
  this->I_body_zz_.set (x);
}

const car::I_body_xz_type& car::
I_body_xz () const
{
  return this->I_body_xz_.get ();
}

car::I_body_xz_type& car::
I_body_xz ()
{
  return this->I_body_xz_.get ();
}

void car::
I_body_xz (const I_body_xz_type& x)
{
  this->I_body_xz_.set (x);
}

const car::I_body_zx_type& car::
I_body_zx () const
{
  return this->I_body_zx_.get ();
}

car::I_body_zx_type& car::
I_body_zx ()
{
  return this->I_body_zx_.get ();
}

void car::
I_body_zx (const I_body_zx_type& x)
{
  this->I_body_zx_.set (x);
}


// initial
// 

const initial::lower_spring_length_type& initial::
lower_spring_length () const
{
  return this->lower_spring_length_.get ();
}

initial::lower_spring_length_type& initial::
lower_spring_length ()
{
  return this->lower_spring_length_.get ();
}

void initial::
lower_spring_length (const lower_spring_length_type& x)
{
  this->lower_spring_length_.set (x);
}

void initial::
lower_spring_length (::std::auto_ptr< lower_spring_length_type > x)
{
  this->lower_spring_length_.set (x);
}

const initial::upper_spring_length_type& initial::
upper_spring_length () const
{
  return this->upper_spring_length_.get ();
}

initial::upper_spring_length_type& initial::
upper_spring_length ()
{
  return this->upper_spring_length_.get ();
}

void initial::
upper_spring_length (const upper_spring_length_type& x)
{
  this->upper_spring_length_.set (x);
}

void initial::
upper_spring_length (::std::auto_ptr< upper_spring_length_type > x)
{
  this->upper_spring_length_.set (x);
}

const initial::vel_tyre_type& initial::
vel_tyre () const
{
  return this->vel_tyre_.get ();
}

initial::vel_tyre_type& initial::
vel_tyre ()
{
  return this->vel_tyre_.get ();
}

void initial::
vel_tyre (const vel_tyre_type& x)
{
  this->vel_tyre_.set (x);
}

void initial::
vel_tyre (::std::auto_ptr< vel_tyre_type > x)
{
  this->vel_tyre_.set (x);
}

const initial::vel_wheel_type& initial::
vel_wheel () const
{
  return this->vel_wheel_.get ();
}

initial::vel_wheel_type& initial::
vel_wheel ()
{
  return this->vel_wheel_.get ();
}

void initial::
vel_wheel (const vel_wheel_type& x)
{
  this->vel_wheel_.set (x);
}

void initial::
vel_wheel (::std::auto_ptr< vel_wheel_type > x)
{
  this->vel_wheel_.set (x);
}

const initial::qi_type& initial::
qi () const
{
  return this->qi_.get ();
}

initial::qi_type& initial::
qi ()
{
  return this->qi_.get ();
}

void initial::
qi (const qi_type& x)
{
  this->qi_.set (x);
}

const initial::qj_type& initial::
qj () const
{
  return this->qj_.get ();
}

initial::qj_type& initial::
qj ()
{
  return this->qj_.get ();
}

void initial::
qj (const qj_type& x)
{
  this->qj_.set (x);
}

const initial::qk_type& initial::
qk () const
{
  return this->qk_.get ();
}

initial::qk_type& initial::
qk ()
{
  return this->qk_.get ();
}

void initial::
qk (const qk_type& x)
{
  this->qk_.set (x);
}

const initial::qr_type& initial::
qr () const
{
  return this->qr_.get ();
}

initial::qr_type& initial::
qr ()
{
  return this->qr_.get ();
}

void initial::
qr (const qr_type& x)
{
  this->qr_.set (x);
}

const initial::vel_body_type& initial::
vel_body () const
{
  return this->vel_body_.get ();
}

initial::vel_body_type& initial::
vel_body ()
{
  return this->vel_body_.get ();
}

void initial::
vel_body (const vel_body_type& x)
{
  this->vel_body_.set (x);
}

const initial::ang_vel_body_x_type& initial::
ang_vel_body_x () const
{
  return this->ang_vel_body_x_.get ();
}

initial::ang_vel_body_x_type& initial::
ang_vel_body_x ()
{
  return this->ang_vel_body_x_.get ();
}

void initial::
ang_vel_body_x (const ang_vel_body_x_type& x)
{
  this->ang_vel_body_x_.set (x);
}

const initial::ang_vel_body_z_type& initial::
ang_vel_body_z () const
{
  return this->ang_vel_body_z_.get ();
}

initial::ang_vel_body_z_type& initial::
ang_vel_body_z ()
{
  return this->ang_vel_body_z_.get ();
}

void initial::
ang_vel_body_z (const ang_vel_body_z_type& x)
{
  this->ang_vel_body_z_.set (x);
}


// external
// 

const external::boundary_conditions_type& external::
boundary_conditions () const
{
  return this->boundary_conditions_.get ();
}

external::boundary_conditions_type& external::
boundary_conditions ()
{
  return this->boundary_conditions_.get ();
}

void external::
boundary_conditions (const boundary_conditions_type& x)
{
  this->boundary_conditions_.set (x);
}

void external::
boundary_conditions (::std::auto_ptr< boundary_conditions_type > x)
{
  this->boundary_conditions_.set (x);
}

const external::force_body_type& external::
force_body () const
{
  return this->force_body_.get ();
}

external::force_body_type& external::
force_body ()
{
  return this->force_body_.get ();
}

void external::
force_body (const force_body_type& x)
{
  this->force_body_.set (x);
}

const external::gravity_type& external::
gravity () const
{
  return this->gravity_.get ();
}

external::gravity_type& external::
gravity ()
{
  return this->gravity_.get ();
}

void external::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}


// simulation
// 

const simulation::solver_type& simulation::
solver () const
{
  return this->solver_.get ();
}

simulation::solver_type& simulation::
solver ()
{
  return this->solver_.get ();
}

void simulation::
solver (const solver_type& x)
{
  this->solver_.set (x);
}

void simulation::
solver (::std::auto_ptr< solver_type > x)
{
  this->solver_.set (x);
}

const simulation::DOF_type& simulation::
DOF () const
{
  return this->DOF_.get ();
}

simulation::DOF_type& simulation::
DOF ()
{
  return this->DOF_.get ();
}

void simulation::
DOF (const DOF_type& x)
{
  this->DOF_.set (x);
}

const simulation::max_num_iter_type& simulation::
max_num_iter () const
{
  return this->max_num_iter_.get ();
}

simulation::max_num_iter_type& simulation::
max_num_iter ()
{
  return this->max_num_iter_.get ();
}

void simulation::
max_num_iter (const max_num_iter_type& x)
{
  this->max_num_iter_.set (x);
}

const simulation::tolerance_type& simulation::
tolerance () const
{
  return this->tolerance_.get ();
}

simulation::tolerance_type& simulation::
tolerance ()
{
  return this->tolerance_.get ();
}

void simulation::
tolerance (const tolerance_type& x)
{
  this->tolerance_.set (x);
}

const simulation::num_time_iter_type& simulation::
num_time_iter () const
{
  return this->num_time_iter_.get ();
}

simulation::num_time_iter_type& simulation::
num_time_iter ()
{
  return this->num_time_iter_.get ();
}

void simulation::
num_time_iter (const num_time_iter_type& x)
{
  this->num_time_iter_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// vector_legs_t
//

vector_legs_t::
vector_legs_t (const rr_type& rr,
               const rl_type& rl,
               const fl_type& fl,
               const fr_type& fr)
: ::xml_schema::type (),
  rr_ (rr, this),
  rl_ (rl, this),
  fl_ (fl, this),
  fr_ (fr, this)
{
}

vector_legs_t::
vector_legs_t (const vector_legs_t& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  rr_ (x.rr_, f, this),
  rl_ (x.rl_, f, this),
  fl_ (x.fl_, f, this),
  fr_ (x.fr_, f, this)
{
}

vector_legs_t::
vector_legs_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  rr_ (this),
  rl_ (this),
  fl_ (this),
  fr_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void vector_legs_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // rr
    //
    if (n.name () == "rr" && n.namespace_ ().empty ())
    {
      if (!rr_.present ())
      {
        this->rr_.set (rr_traits::create (i, f, this));
        continue;
      }
    }

    // rl
    //
    if (n.name () == "rl" && n.namespace_ ().empty ())
    {
      if (!rl_.present ())
      {
        this->rl_.set (rl_traits::create (i, f, this));
        continue;
      }
    }

    // fl
    //
    if (n.name () == "fl" && n.namespace_ ().empty ())
    {
      if (!fl_.present ())
      {
        this->fl_.set (fl_traits::create (i, f, this));
        continue;
      }
    }

    // fr
    //
    if (n.name () == "fr" && n.namespace_ ().empty ())
    {
      if (!fr_.present ())
      {
        this->fr_.set (fr_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!rr_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rr",
      "");
  }

  if (!rl_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rl",
      "");
  }

  if (!fl_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "fl",
      "");
  }

  if (!fr_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "fr",
      "");
  }
}

vector_legs_t* vector_legs_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vector_legs_t (*this, f, c);
}

vector_legs_t& vector_legs_t::
operator= (const vector_legs_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->rr_ = x.rr_;
    this->rl_ = x.rl_;
    this->fl_ = x.fl_;
    this->fr_ = x.fr_;
  }

  return *this;
}

vector_legs_t::
~vector_legs_t ()
{
}

// car_settings_t
//

car_settings_t::
car_settings_t (const car_type& car,
                const initial_type& initial,
                const external_type& external,
                const simulation_type& simulation)
: ::xml_schema::type (),
  car_ (car, this),
  initial_ (initial, this),
  external_ (external, this),
  simulation_ (simulation, this)
{
}

car_settings_t::
car_settings_t (::std::auto_ptr< car_type > car,
                ::std::auto_ptr< initial_type > initial,
                ::std::auto_ptr< external_type > external,
                ::std::auto_ptr< simulation_type > simulation)
: ::xml_schema::type (),
  car_ (car, this),
  initial_ (initial, this),
  external_ (external, this),
  simulation_ (simulation, this)
{
}

car_settings_t::
car_settings_t (const car_settings_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  car_ (x.car_, f, this),
  initial_ (x.initial_, f, this),
  external_ (x.external_, f, this),
  simulation_ (x.simulation_, f, this)
{
}

car_settings_t::
car_settings_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  car_ (this),
  initial_ (this),
  external_ (this),
  simulation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void car_settings_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // car
    //
    if (n.name () == "car" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< car_type > r (
        car_traits::create (i, f, this));

      if (!car_.present ())
      {
        this->car_.set (r);
        continue;
      }
    }

    // initial
    //
    if (n.name () == "initial" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< initial_type > r (
        initial_traits::create (i, f, this));

      if (!initial_.present ())
      {
        this->initial_.set (r);
        continue;
      }
    }

    // external
    //
    if (n.name () == "external" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< external_type > r (
        external_traits::create (i, f, this));

      if (!external_.present ())
      {
        this->external_.set (r);
        continue;
      }
    }

    // simulation
    //
    if (n.name () == "simulation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< simulation_type > r (
        simulation_traits::create (i, f, this));

      if (!simulation_.present ())
      {
        this->simulation_.set (r);
        continue;
      }
    }

    break;
  }

  if (!car_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "car",
      "");
  }

  if (!initial_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial",
      "");
  }

  if (!external_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "external",
      "");
  }

  if (!simulation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "simulation",
      "");
  }
}

car_settings_t* car_settings_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class car_settings_t (*this, f, c);
}

car_settings_t& car_settings_t::
operator= (const car_settings_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->car_ = x.car_;
    this->initial_ = x.initial_;
    this->external_ = x.external_;
    this->simulation_ = x.simulation_;
  }

  return *this;
}

car_settings_t::
~car_settings_t ()
{
}

// car
//

car::
car (const k_tyre_type& k_tyre,
     const k_body_type& k_body,
     const l_lat_type& l_lat,
     const l_long_type& l_long,
     const mass_wheel_type& mass_wheel,
     const mass_tyre_type& mass_tyre,
     const lower_spring_length_type& lower_spring_length,
     const upper_spring_length_type& upper_spring_length,
     const mass_body_type& mass_body,
     const I_body_xx_type& I_body_xx,
     const I_body_zz_type& I_body_zz,
     const I_body_xz_type& I_body_xz,
     const I_body_zx_type& I_body_zx)
: ::xml_schema::type (),
  k_tyre_ (k_tyre, this),
  k_body_ (k_body, this),
  l_lat_ (l_lat, this),
  l_long_ (l_long, this),
  mass_wheel_ (mass_wheel, this),
  mass_tyre_ (mass_tyre, this),
  lower_spring_length_ (lower_spring_length, this),
  upper_spring_length_ (upper_spring_length, this),
  mass_body_ (mass_body, this),
  I_body_xx_ (I_body_xx, this),
  I_body_zz_ (I_body_zz, this),
  I_body_xz_ (I_body_xz, this),
  I_body_zx_ (I_body_zx, this)
{
}

car::
car (::std::auto_ptr< k_tyre_type > k_tyre,
     ::std::auto_ptr< k_body_type > k_body,
     ::std::auto_ptr< l_lat_type > l_lat,
     ::std::auto_ptr< l_long_type > l_long,
     ::std::auto_ptr< mass_wheel_type > mass_wheel,
     ::std::auto_ptr< mass_tyre_type > mass_tyre,
     ::std::auto_ptr< lower_spring_length_type > lower_spring_length,
     ::std::auto_ptr< upper_spring_length_type > upper_spring_length,
     const mass_body_type& mass_body,
     const I_body_xx_type& I_body_xx,
     const I_body_zz_type& I_body_zz,
     const I_body_xz_type& I_body_xz,
     const I_body_zx_type& I_body_zx)
: ::xml_schema::type (),
  k_tyre_ (k_tyre, this),
  k_body_ (k_body, this),
  l_lat_ (l_lat, this),
  l_long_ (l_long, this),
  mass_wheel_ (mass_wheel, this),
  mass_tyre_ (mass_tyre, this),
  lower_spring_length_ (lower_spring_length, this),
  upper_spring_length_ (upper_spring_length, this),
  mass_body_ (mass_body, this),
  I_body_xx_ (I_body_xx, this),
  I_body_zz_ (I_body_zz, this),
  I_body_xz_ (I_body_xz, this),
  I_body_zx_ (I_body_zx, this)
{
}

car::
car (const car& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  k_tyre_ (x.k_tyre_, f, this),
  k_body_ (x.k_body_, f, this),
  l_lat_ (x.l_lat_, f, this),
  l_long_ (x.l_long_, f, this),
  mass_wheel_ (x.mass_wheel_, f, this),
  mass_tyre_ (x.mass_tyre_, f, this),
  lower_spring_length_ (x.lower_spring_length_, f, this),
  upper_spring_length_ (x.upper_spring_length_, f, this),
  mass_body_ (x.mass_body_, f, this),
  I_body_xx_ (x.I_body_xx_, f, this),
  I_body_zz_ (x.I_body_zz_, f, this),
  I_body_xz_ (x.I_body_xz_, f, this),
  I_body_zx_ (x.I_body_zx_, f, this)
{
}

car::
car (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  k_tyre_ (this),
  k_body_ (this),
  l_lat_ (this),
  l_long_ (this),
  mass_wheel_ (this),
  mass_tyre_ (this),
  lower_spring_length_ (this),
  upper_spring_length_ (this),
  mass_body_ (this),
  I_body_xx_ (this),
  I_body_zz_ (this),
  I_body_xz_ (this),
  I_body_zx_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void car::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // k_tyre
    //
    if (n.name () == "k_tyre" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< k_tyre_type > r (
        k_tyre_traits::create (i, f, this));

      if (!k_tyre_.present ())
      {
        this->k_tyre_.set (r);
        continue;
      }
    }

    // k_body
    //
    if (n.name () == "k_body" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< k_body_type > r (
        k_body_traits::create (i, f, this));

      if (!k_body_.present ())
      {
        this->k_body_.set (r);
        continue;
      }
    }

    // l_lat
    //
    if (n.name () == "l_lat" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< l_lat_type > r (
        l_lat_traits::create (i, f, this));

      if (!l_lat_.present ())
      {
        this->l_lat_.set (r);
        continue;
      }
    }

    // l_long
    //
    if (n.name () == "l_long" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< l_long_type > r (
        l_long_traits::create (i, f, this));

      if (!l_long_.present ())
      {
        this->l_long_.set (r);
        continue;
      }
    }

    // mass_wheel
    //
    if (n.name () == "mass_wheel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mass_wheel_type > r (
        mass_wheel_traits::create (i, f, this));

      if (!mass_wheel_.present ())
      {
        this->mass_wheel_.set (r);
        continue;
      }
    }

    // mass_tyre
    //
    if (n.name () == "mass_tyre" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mass_tyre_type > r (
        mass_tyre_traits::create (i, f, this));

      if (!mass_tyre_.present ())
      {
        this->mass_tyre_.set (r);
        continue;
      }
    }

    // lower_spring_length
    //
    if (n.name () == "lower_spring_length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lower_spring_length_type > r (
        lower_spring_length_traits::create (i, f, this));

      if (!lower_spring_length_.present ())
      {
        this->lower_spring_length_.set (r);
        continue;
      }
    }

    // upper_spring_length
    //
    if (n.name () == "upper_spring_length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< upper_spring_length_type > r (
        upper_spring_length_traits::create (i, f, this));

      if (!upper_spring_length_.present ())
      {
        this->upper_spring_length_.set (r);
        continue;
      }
    }

    // mass_body
    //
    if (n.name () == "mass_body" && n.namespace_ ().empty ())
    {
      if (!mass_body_.present ())
      {
        this->mass_body_.set (mass_body_traits::create (i, f, this));
        continue;
      }
    }

    // I_body_xx
    //
    if (n.name () == "I_body_xx" && n.namespace_ ().empty ())
    {
      if (!I_body_xx_.present ())
      {
        this->I_body_xx_.set (I_body_xx_traits::create (i, f, this));
        continue;
      }
    }

    // I_body_zz
    //
    if (n.name () == "I_body_zz" && n.namespace_ ().empty ())
    {
      if (!I_body_zz_.present ())
      {
        this->I_body_zz_.set (I_body_zz_traits::create (i, f, this));
        continue;
      }
    }

    // I_body_xz
    //
    if (n.name () == "I_body_xz" && n.namespace_ ().empty ())
    {
      if (!I_body_xz_.present ())
      {
        this->I_body_xz_.set (I_body_xz_traits::create (i, f, this));
        continue;
      }
    }

    // I_body_zx
    //
    if (n.name () == "I_body_zx" && n.namespace_ ().empty ())
    {
      if (!I_body_zx_.present ())
      {
        this->I_body_zx_.set (I_body_zx_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!k_tyre_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "k_tyre",
      "");
  }

  if (!k_body_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "k_body",
      "");
  }

  if (!l_lat_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "l_lat",
      "");
  }

  if (!l_long_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "l_long",
      "");
  }

  if (!mass_wheel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass_wheel",
      "");
  }

  if (!mass_tyre_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass_tyre",
      "");
  }

  if (!lower_spring_length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lower_spring_length",
      "");
  }

  if (!upper_spring_length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "upper_spring_length",
      "");
  }

  if (!mass_body_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass_body",
      "");
  }

  if (!I_body_xx_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "I_body_xx",
      "");
  }

  if (!I_body_zz_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "I_body_zz",
      "");
  }

  if (!I_body_xz_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "I_body_xz",
      "");
  }

  if (!I_body_zx_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "I_body_zx",
      "");
  }
}

car* car::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class car (*this, f, c);
}

car& car::
operator= (const car& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->k_tyre_ = x.k_tyre_;
    this->k_body_ = x.k_body_;
    this->l_lat_ = x.l_lat_;
    this->l_long_ = x.l_long_;
    this->mass_wheel_ = x.mass_wheel_;
    this->mass_tyre_ = x.mass_tyre_;
    this->lower_spring_length_ = x.lower_spring_length_;
    this->upper_spring_length_ = x.upper_spring_length_;
    this->mass_body_ = x.mass_body_;
    this->I_body_xx_ = x.I_body_xx_;
    this->I_body_zz_ = x.I_body_zz_;
    this->I_body_xz_ = x.I_body_xz_;
    this->I_body_zx_ = x.I_body_zx_;
  }

  return *this;
}

car::
~car ()
{
}

// initial
//

initial::
initial (const lower_spring_length_type& lower_spring_length,
         const upper_spring_length_type& upper_spring_length,
         const vel_tyre_type& vel_tyre,
         const vel_wheel_type& vel_wheel,
         const qi_type& qi,
         const qj_type& qj,
         const qk_type& qk,
         const qr_type& qr,
         const vel_body_type& vel_body,
         const ang_vel_body_x_type& ang_vel_body_x,
         const ang_vel_body_z_type& ang_vel_body_z)
: ::xml_schema::type (),
  lower_spring_length_ (lower_spring_length, this),
  upper_spring_length_ (upper_spring_length, this),
  vel_tyre_ (vel_tyre, this),
  vel_wheel_ (vel_wheel, this),
  qi_ (qi, this),
  qj_ (qj, this),
  qk_ (qk, this),
  qr_ (qr, this),
  vel_body_ (vel_body, this),
  ang_vel_body_x_ (ang_vel_body_x, this),
  ang_vel_body_z_ (ang_vel_body_z, this)
{
}

initial::
initial (::std::auto_ptr< lower_spring_length_type > lower_spring_length,
         ::std::auto_ptr< upper_spring_length_type > upper_spring_length,
         ::std::auto_ptr< vel_tyre_type > vel_tyre,
         ::std::auto_ptr< vel_wheel_type > vel_wheel,
         const qi_type& qi,
         const qj_type& qj,
         const qk_type& qk,
         const qr_type& qr,
         const vel_body_type& vel_body,
         const ang_vel_body_x_type& ang_vel_body_x,
         const ang_vel_body_z_type& ang_vel_body_z)
: ::xml_schema::type (),
  lower_spring_length_ (lower_spring_length, this),
  upper_spring_length_ (upper_spring_length, this),
  vel_tyre_ (vel_tyre, this),
  vel_wheel_ (vel_wheel, this),
  qi_ (qi, this),
  qj_ (qj, this),
  qk_ (qk, this),
  qr_ (qr, this),
  vel_body_ (vel_body, this),
  ang_vel_body_x_ (ang_vel_body_x, this),
  ang_vel_body_z_ (ang_vel_body_z, this)
{
}

initial::
initial (const initial& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  lower_spring_length_ (x.lower_spring_length_, f, this),
  upper_spring_length_ (x.upper_spring_length_, f, this),
  vel_tyre_ (x.vel_tyre_, f, this),
  vel_wheel_ (x.vel_wheel_, f, this),
  qi_ (x.qi_, f, this),
  qj_ (x.qj_, f, this),
  qk_ (x.qk_, f, this),
  qr_ (x.qr_, f, this),
  vel_body_ (x.vel_body_, f, this),
  ang_vel_body_x_ (x.ang_vel_body_x_, f, this),
  ang_vel_body_z_ (x.ang_vel_body_z_, f, this)
{
}

initial::
initial (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  lower_spring_length_ (this),
  upper_spring_length_ (this),
  vel_tyre_ (this),
  vel_wheel_ (this),
  qi_ (this),
  qj_ (this),
  qk_ (this),
  qr_ (this),
  vel_body_ (this),
  ang_vel_body_x_ (this),
  ang_vel_body_z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void initial::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // lower_spring_length
    //
    if (n.name () == "lower_spring_length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lower_spring_length_type > r (
        lower_spring_length_traits::create (i, f, this));

      if (!lower_spring_length_.present ())
      {
        this->lower_spring_length_.set (r);
        continue;
      }
    }

    // upper_spring_length
    //
    if (n.name () == "upper_spring_length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< upper_spring_length_type > r (
        upper_spring_length_traits::create (i, f, this));

      if (!upper_spring_length_.present ())
      {
        this->upper_spring_length_.set (r);
        continue;
      }
    }

    // vel_tyre
    //
    if (n.name () == "vel_tyre" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vel_tyre_type > r (
        vel_tyre_traits::create (i, f, this));

      if (!vel_tyre_.present ())
      {
        this->vel_tyre_.set (r);
        continue;
      }
    }

    // vel_wheel
    //
    if (n.name () == "vel_wheel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vel_wheel_type > r (
        vel_wheel_traits::create (i, f, this));

      if (!vel_wheel_.present ())
      {
        this->vel_wheel_.set (r);
        continue;
      }
    }

    // qi
    //
    if (n.name () == "qi" && n.namespace_ ().empty ())
    {
      if (!qi_.present ())
      {
        this->qi_.set (qi_traits::create (i, f, this));
        continue;
      }
    }

    // qj
    //
    if (n.name () == "qj" && n.namespace_ ().empty ())
    {
      if (!qj_.present ())
      {
        this->qj_.set (qj_traits::create (i, f, this));
        continue;
      }
    }

    // qk
    //
    if (n.name () == "qk" && n.namespace_ ().empty ())
    {
      if (!qk_.present ())
      {
        this->qk_.set (qk_traits::create (i, f, this));
        continue;
      }
    }

    // qr
    //
    if (n.name () == "qr" && n.namespace_ ().empty ())
    {
      if (!qr_.present ())
      {
        this->qr_.set (qr_traits::create (i, f, this));
        continue;
      }
    }

    // vel_body
    //
    if (n.name () == "vel_body" && n.namespace_ ().empty ())
    {
      if (!vel_body_.present ())
      {
        this->vel_body_.set (vel_body_traits::create (i, f, this));
        continue;
      }
    }

    // ang_vel_body_x
    //
    if (n.name () == "ang_vel_body_x" && n.namespace_ ().empty ())
    {
      if (!ang_vel_body_x_.present ())
      {
        this->ang_vel_body_x_.set (ang_vel_body_x_traits::create (i, f, this));
        continue;
      }
    }

    // ang_vel_body_z
    //
    if (n.name () == "ang_vel_body_z" && n.namespace_ ().empty ())
    {
      if (!ang_vel_body_z_.present ())
      {
        this->ang_vel_body_z_.set (ang_vel_body_z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!lower_spring_length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "lower_spring_length",
      "");
  }

  if (!upper_spring_length_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "upper_spring_length",
      "");
  }

  if (!vel_tyre_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel_tyre",
      "");
  }

  if (!vel_wheel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel_wheel",
      "");
  }

  if (!qi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qi",
      "");
  }

  if (!qj_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qj",
      "");
  }

  if (!qk_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qk",
      "");
  }

  if (!qr_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qr",
      "");
  }

  if (!vel_body_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "vel_body",
      "");
  }

  if (!ang_vel_body_x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ang_vel_body_x",
      "");
  }

  if (!ang_vel_body_z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ang_vel_body_z",
      "");
  }
}

initial* initial::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class initial (*this, f, c);
}

initial& initial::
operator= (const initial& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->lower_spring_length_ = x.lower_spring_length_;
    this->upper_spring_length_ = x.upper_spring_length_;
    this->vel_tyre_ = x.vel_tyre_;
    this->vel_wheel_ = x.vel_wheel_;
    this->qi_ = x.qi_;
    this->qj_ = x.qj_;
    this->qk_ = x.qk_;
    this->qr_ = x.qr_;
    this->vel_body_ = x.vel_body_;
    this->ang_vel_body_x_ = x.ang_vel_body_x_;
    this->ang_vel_body_z_ = x.ang_vel_body_z_;
  }

  return *this;
}

initial::
~initial ()
{
}

// external
//

external::
external (const boundary_conditions_type& boundary_conditions,
          const force_body_type& force_body,
          const gravity_type& gravity)
: ::xml_schema::type (),
  boundary_conditions_ (boundary_conditions, this),
  force_body_ (force_body, this),
  gravity_ (gravity, this)
{
}

external::
external (const external& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundary_conditions_ (x.boundary_conditions_, f, this),
  force_body_ (x.force_body_, f, this),
  gravity_ (x.gravity_, f, this)
{
}

external::
external (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundary_conditions_ (this),
  force_body_ (this),
  gravity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void external::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundary_conditions
    //
    if (n.name () == "boundary_conditions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< boundary_conditions_type > r (
        boundary_conditions_traits::create (i, f, this));

      if (!boundary_conditions_.present ())
      {
        this->boundary_conditions_.set (r);
        continue;
      }
    }

    // force_body
    //
    if (n.name () == "force_body" && n.namespace_ ().empty ())
    {
      if (!force_body_.present ())
      {
        this->force_body_.set (force_body_traits::create (i, f, this));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      if (!gravity_.present ())
      {
        this->gravity_.set (gravity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!boundary_conditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary_conditions",
      "");
  }

  if (!force_body_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "force_body",
      "");
  }

  if (!gravity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "gravity",
      "");
  }
}

external* external::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class external (*this, f, c);
}

external& external::
operator= (const external& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->boundary_conditions_ = x.boundary_conditions_;
    this->force_body_ = x.force_body_;
    this->gravity_ = x.gravity_;
  }

  return *this;
}

external::
~external ()
{
}

// simulation
//

simulation::
simulation (const solver_type& solver,
            const DOF_type& DOF,
            const max_num_iter_type& max_num_iter,
            const tolerance_type& tolerance,
            const num_time_iter_type& num_time_iter)
: ::xml_schema::type (),
  solver_ (solver, this),
  DOF_ (DOF, this),
  max_num_iter_ (max_num_iter, this),
  tolerance_ (tolerance, this),
  num_time_iter_ (num_time_iter, this)
{
}

simulation::
simulation (const simulation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  solver_ (x.solver_, f, this),
  DOF_ (x.DOF_, f, this),
  max_num_iter_ (x.max_num_iter_, f, this),
  tolerance_ (x.tolerance_, f, this),
  num_time_iter_ (x.num_time_iter_, f, this)
{
}

simulation::
simulation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  solver_ (this),
  DOF_ (this),
  max_num_iter_ (this),
  tolerance_ (this),
  num_time_iter_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // solver
    //
    if (n.name () == "solver" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solver_type > r (
        solver_traits::create (i, f, this));

      if (!solver_.present ())
      {
        this->solver_.set (r);
        continue;
      }
    }

    // DOF
    //
    if (n.name () == "DOF" && n.namespace_ ().empty ())
    {
      if (!DOF_.present ())
      {
        this->DOF_.set (DOF_traits::create (i, f, this));
        continue;
      }
    }

    // max_num_iter
    //
    if (n.name () == "max_num_iter" && n.namespace_ ().empty ())
    {
      if (!max_num_iter_.present ())
      {
        this->max_num_iter_.set (max_num_iter_traits::create (i, f, this));
        continue;
      }
    }

    // tolerance
    //
    if (n.name () == "tolerance" && n.namespace_ ().empty ())
    {
      if (!tolerance_.present ())
      {
        this->tolerance_.set (tolerance_traits::create (i, f, this));
        continue;
      }
    }

    // num_time_iter
    //
    if (n.name () == "num_time_iter" && n.namespace_ ().empty ())
    {
      if (!num_time_iter_.present ())
      {
        this->num_time_iter_.set (num_time_iter_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!solver_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "solver",
      "");
  }

  if (!DOF_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DOF",
      "");
  }

  if (!max_num_iter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "max_num_iter",
      "");
  }

  if (!tolerance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tolerance",
      "");
  }

  if (!num_time_iter_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "num_time_iter",
      "");
  }
}

simulation* simulation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation (*this, f, c);
}

simulation& simulation::
operator= (const simulation& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->solver_ = x.solver_;
    this->DOF_ = x.DOF_;
    this->max_num_iter_ = x.max_num_iter_;
    this->tolerance_ = x.tolerance_;
    this->num_time_iter_ = x.num_time_iter_;
  }

  return *this;
}

simulation::
~simulation ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::car_settings_t >
car_settings (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::car_settings_t > (
    ::car_settings (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::car_settings_t >
car_settings (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::car_settings_t > (
    ::car_settings (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::car_settings_t >
car_settings (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::car_settings_t > (
    ::car_settings (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::car_settings_t >
car_settings (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::car_settings (isrc, f, p);
}

::std::auto_ptr< ::car_settings_t >
car_settings (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::car_settings (isrc, h, f, p);
}

::std::auto_ptr< ::car_settings_t >
car_settings (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::car_settings (isrc, h, f, p);
}

::std::auto_ptr< ::car_settings_t >
car_settings (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::car_settings (isrc, f, p);
}

::std::auto_ptr< ::car_settings_t >
car_settings (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::car_settings (isrc, h, f, p);
}

::std::auto_ptr< ::car_settings_t >
car_settings (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::car_settings (isrc, h, f, p);
}

::std::auto_ptr< ::car_settings_t >
car_settings (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::car_settings_t > (
    ::car_settings (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::car_settings_t >
car_settings (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::car_settings_t > (
    ::car_settings (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::car_settings_t >
car_settings (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::car_settings_t > (
    ::car_settings (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::car_settings_t >
car_settings (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::car_settings_t > (
      ::car_settings (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "car_settings" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::car_settings_t > r (
      ::xsd::cxx::tree::traits< ::car_settings_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "car_settings",
    "");
}

::std::auto_ptr< ::car_settings_t >
car_settings (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "car_settings" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::car_settings_t > r (
      ::xsd::cxx::tree::traits< ::car_settings_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "car_settings",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

